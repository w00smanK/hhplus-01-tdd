
## 심화 과제 구현 정리

### 포인트 관리 시스템에서의 동시성 제어

동일한 사용자의 포인트 충전 및 사용과 같은 트랜잭션을 처리같은 유저에 대해 동시에 여러 요청이 들어올 때 포인트 자원을 공유하기 때문에 동시성 제어가 필요합니다.
동시성 제어를 통해 특정 사용자에 대한 공유 자원이 각각의 요청에 대해 간섭받지 않게 구현해야 한다.

* 발생 할 수 있는 동시성 문제

  포인트와 같은 금전적 트랜잭션을 처리할 때, 동일한 사용자에 대한 여러 요청이 동시에 들어오면 일관성이 없는 상태가 발생할 수 있습니다. 
  예를 들어, 두 스레드가 동시에 포인트를 충전하거나 사용하면, 최종 포인트 잔액이 올바르게 계산되지 않을 수 있습니다.

* 해결 방법: 사용자별 고유 락 사용
  동시성 문제를 해결하기 위해 ConcurrentHashMap<Long, ReentrantLock>을 사용하여 사용자별로 고유한 락을 생성하고 관리합니다.
  ReentrantLock은 특정 사용자에 대한 요청이 순차적으로 처리되도록 보장해줍니다.
  
  UserLockManager: 사용자의 락을 관리하는 유틸리티 클래스입니다. 특정 사용자의 요청이 들어오면 그 사용자에 대해 고유한 락을 할당하고, 요청이 끝나면 락을 해제합니다. 
  unlock 메서드를 사용하여 락을 간편하게 사용할 수 있습니다.


* 구현 세부 사항
  테스트에서는 Executors.newFixedThreadPool()과 CompletableFuture를 사용하여 동시에 여러 스레드가 동일한 사용자에 대해 요청을 처리하는 상황을 시뮬레이션했습니다.

* 동시성 테스트
  두 개의 스레드가 동시에 한 사용자의 포인트를 충전하거나 사용하는 시나리오를 테스트하여, 요청이 독립적으로 처리되는지 확인했습니다. 



## 동시성 (Concurrency) 이란?

---

* **정의:**
    * 동시성이란 하나의 시스템이 여러 작업을 동시에 처리하는 것처럼 보이게 하는 기술입니다.
    * 실제로는 CPU가 여러 작업을 번갈아 가며 실행하지만, 빠른 전환 속도 덕분에 사용자에게는 동시에 실행되는 것처럼 느껴집니다.
* **핵심:**
    * 동시성은 작업을 분할하고 스케줄링하여 효율성을 높이는 데 중점을 둡니다.
    * 주로 I/O 작업이 빈번한 환경에서 성능 향상을 위해 사용됩니다.

## 동시성의 장점

---

* **성능 향상:**
    * I/O 작업과 같이 대기 시간이 긴 작업을 처리하는 동안 CPU가 다른 작업을 수행하여 전체 시스템의 처리량을 높입니다.
    * 사용자 경험을 향상시키고 시스템 응답 시간을 단축합니다.
* **자원 활용 극대화:**
    * CPU와 메모리 등 시스템 자원을 효율적으로 사용하여 작업 처리 능력을 극대화합니다.
    * 다수의 사용자가 동시에 시스템을 사용하는 환경에서 효율적인 자원 관리를 가능하게 합니다.
* **유연성 및 확장성:**
    * 여러 작업을 독립적으로 처리하여 시스템의 유연성을 높이고, 필요에 따라 시스템을 확장하기 용이합니다.
    * 모듈화된 작업을 통해 코드 유지보수성을 향상시킵니다.

## 동시성의 단점

---

* **복잡성 증가:**
    * 여러 스레드 또는 프로세스가 동시에 데이터에 접근하고 변경할 때 발생하는 동기화 문제를 해결해야 합니다.
    * 경쟁 조건, 교착 상태, 기아 상태 등 다양한 동시성 관련 문제가 발생할 수 있습니다.
* **오버헤드 발생:**
    * 스레드 또는 프로세스 간의 컨텍스트 스위칭은 시스템에 추가적인 오버헤드를 발생시킵니다.
    * 과도한 동시성 처리는 오히려 성능 저하를 야기할 수 있습니다.
* **디버깅 어려움:**
    * 동시성 관련 오류는 발생 빈도가 낮고 재현하기 어려워 디버깅이 복잡합니다.
    * 다양한 스레드 또는 프로세스 간의 상호작용을 추적하고 분석해야 합니다.





# 🔒 자바의 동기화 구현 전략 (Java Synchronization Techniques)

멀티스레드 환경에서 안전하게 데이터를 공유하거나 상태를 관리하려면 **동기화(Synchronization)** 처리가 필수입니다.  
Java에서는 다양한 방식으로 동기화를 구현할 수 있으며, 각 방식은 목적과 상황에 따라 선택될 수 있습니다.

---

## 1. `synchronized` 키워드

Java에서 제공하는 가장 기본적이면서도 간단한 동기화 방식입니다.  
메서드나 특정 코드 블록에 `synchronized` 키워드를 붙여 **임계 구역(Critical Section)**을 설정합니다.

✅ **특징**
* 상호 배제(Mutual Exclusion) 보장  
* 가장 단순하고 직관적인 방식  
* 내부적으로 객체 모니터(monitor)를 이용한 락 구현  
* 세밀한 락 제어나 조건변수 사용 불가  

---

## 2. `ReentrantLock`

`synchronized`와 유사한 기능을 제공하지만, 더 유연한 락 제어 기능을 제공합니다.  
`java.util.concurrent.locks.Lock` 인터페이스를 구현한 클래스입니다.

✅ **특징**
* 명시적 `lock()` / `unlock()` 제어  
* `tryLock()`을 통해 락 획득 여부 판단 가능  
* `lockInterruptibly()`로 락 대기 중 인터럽트 처리 가능  
* **공정성(fairness)** 옵션 제공 → 기아 현상 방지  

---

## 3. 동시성 컬렉션 (`ConcurrentDataStructure`)

Java 1.5부터 도입된 **동시성 컬렉션**은 내부적으로 이미 동기화 처리가 되어 있어  
멀티스레드 환경에서 안전하게 사용할 수 있습니다.

✅ **주요 클래스**
* `ConcurrentHashMap`  
* `CopyOnWriteArrayList`  
* `BlockingQueue` (예: `ArrayBlockingQueue`, `LinkedBlockingQueue`)

✅ **특징**
* 일반 컬렉션(`HashMap`, `ArrayList`)보다 동시성에 강함  
* 락 분할(segmented locking) 또는 복사 기반 전략 사용  
* `null` 키/값 허용 여부 등 사용법이 일부 다름  

---

## 4. 원자 클래스 (`Atomic`)

`java.util.concurrent.atomic` 패키지의 클래스들은  
**CAS(Compare-And-Swap)** 기반으로 동시성을 제어하며, 락을 사용하지 않고도 안전한 연산이 가능합니다.

✅ **대표 클래스**
* `AtomicInteger`  
* `AtomicLong`  
* `AtomicReference`

✅ **특징**
* 경량 동기화 (락 없는 동시성 처리)  
* 반복적이고 단순한 연산에 적합 (카운트)
